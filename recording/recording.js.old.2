/* Copyright (c) 2021 Nextiva, Inc. to Present.
 * All rights reserved.
 * Connect-Media-Recordings
 *
 * Recording Chime Meeting using ffmpeg to S3 bucket
 * Note: if working local, then specify in default.json
 * and you can work with a local ffmpeg that mimicks input
 * and output of the actual application running on ec2 instance.
 *
 * Real functionality uses docker that creates an X11 terminal running firefox that is
 * recorded for saving as a file. Rather than duplicating docker/linux setup, set the
 * debug option to true and then use OSX with ffmpeg, as used in this script for simplicity
 *
 * If developing locally, before running, be certain to get the correct index number for screen
 * capture and audio capture using this command from command-line
 * ffmpeg -f avfoundation -list_devices true -i ""
 *
 * call recording with bucket-name, media-call-id, screen width, screen height
 */

const { spawn } = require("child_process");
const { S3Uploader } = require("./utils/upload");
const logger = require("./utils/logger.js");
const config = require("config");

// get the bucket name and height and width of screen from
// shell script

const args = process.argv.slice(2);
const BUCKET_NAME = args[0];
const MEDIA_CALL_ID = args[1];

console.log("args: ", args);

logger
  .logger()
  .log(
    "info",
    `BUCKET_NAME: ${BUCKET_NAME} and MEDIA_CALL_ID: ${MEDIA_CALL_ID}`
  );

const BROWSER_SCREEN_WIDTH = args[2];
const BROWSER_SCREEN_HEIGHT = args[3];

logger
  .logger()
  .log(
    "debug",
    `BROWSER_SCREEN_WIDTH: ${BROWSER_SCREEN_WIDTH}, BROWSER_SCREEN_HEIGHT: ${BROWSER_SCREEN_HEIGHT}`
  );

// These constants are ignored if running locally

const MEETING_URL = process.env.MEETING_URL || "Not present in environment";
logger.logger().log("info", `MEETING_URL: ${MEETING_URL}`);

const VIDEO_BITRATE = 3000;
const VIDEO_FRAMERATE = 30;
const VIDEO_GOP = VIDEO_FRAMERATE * 2;
const AUDIO_BITRATE = "160k";
const AUDIO_SAMPLERATE = 44100;
const AUDIO_CHANNELS = 2;
const DISPLAY = process.env.DISPLAY;

// End ignored constants if running locally

const FFMPEG_LOG_LEVEL = config.get("ffmpeg-config.logLevel");

// if doing local development, assumption is you are using OSX, if Actual Application, then see Docker container.
// fmpeg -f avfoundation -i "1:0" -vf  "crop=1020:1080:0:0" -pix_fmt yuv420p -y -r 30 test.mp4

var transcodeStreamToOutput;

// if local development use the local recording settings
// otherwise use the real ffmpeg recording

// -nostdin: run without console stdin
// -y: overwrite file if exists
// -s: screen/browser width x screen/browser height
// -r: framerate to record
// -i: if debug, then assumption is main display output and microphone input

if (config.get("environment-config.isLocal") == true) {
  // debug settings for personal OSX computer's settings, see note above
  // to determine these values

  var INPUT_SCREEN_CAPTURE = "1";
  var INPUT_SOUND_CAPTURE = "0";

  logger.logger().log("debug", "in debug environment for ffmpeg");
  transcodeStreamToOutput = spawn("ffmpeg", [
    "-f",
    "avfoundation",
    "-loglevel",
    `${FFMPEG_LOG_LEVEL}`,
    "-y",
    "-i",
    `${INPUT_SCREEN_CAPTURE}:${INPUT_SOUND_CAPTURE}`,
    "-vf",
    "crop=1020:1080:0:0",
    "-pix_fmt",
    "yuv420p",
    "-y",
    "-r",
    "30",
    "test.mp4",
  ]);
} else {
  transcodeStreamToOutput = spawn("ffmpeg", [
    "-hide_banner",
    "-loglevel",
    `${FFMPEG_LOG_LEVEL}`,
    "-nostdin",
    "-s",
    `${BROWSER_SCREEN_WIDTH}x${BROWSER_SCREEN_HEIGHT}`,
    // video frame rate
    "-r",
    `${VIDEO_FRAMERATE}`,
    // hides the mouse cursor from the resulting video
    "-draw_mouse",
    "0",
    // grab the x11 display as video input
    "-f",
    "x11grab",
    "-i",
    `${DISPLAY}`,
    // grab pulse as audio input
    "-f",
    "pulse",
    "-ac",
    "2",
    "-i",
    "default",
    // codec video with libx264
    "-c:v",
    "libx264",
    "-pix_fmt",
    "yuv420p",
    "-profile:v",
    "main",
    "-preset",
    "veryfast",
    "-x264opts",
    "nal-hrd=cbr:no-scenecut",
    "-minrate",
    `${VIDEO_BITRATE}`,
    "-maxrate",
    `${VIDEO_BITRATE}`,
    "-g",
    `${VIDEO_GOP}`,
    // apply a fixed delay to the audio stream in order to synchronize it with the video stream
    "-filter_complex",
    "adelay=delays=1000|1000",
    // codec audio with aac
    "-c:a",
    "aac",
    "-b:a",
    `${AUDIO_BITRATE}`,
    "-ac",
    `${AUDIO_CHANNELS}`,
    "-ar",
    `${AUDIO_SAMPLERATE}`,
    // adjust fragmentation to prevent seeking(resolve issue: muxer does not support non seekable output)
    "-movflags",
    "frag_keyframe+empty_moov",
    // set output format to mp4 and output file to stdout
    "-f",
    "mp4",
    "-",
  ]);
}

// capture the output stream and log to log file and console

transcodeStreamToOutput.stderr.on("data", (data) => {
  logger
    .logger()
    .log(
      "error",
      `[transcodeStreamToOutput process] stderr: ${new Date().toISOString()} ffmpeg: ${data}`
    );
});

// create the bucket name for the outputed file

const timestamp = new Date();
const fileTimestamp = timestamp.toISOString().substring(0, 19);
const year = timestamp.getFullYear();
const month = timestamp.getMonth() + 1;
const day = timestamp.getDate();
const hour = timestamp.getUTCHours();

// create the file to upload to S3 bucket
// format: year/month/day/hour/media-call-id
// file format: mp4

const fileName = `${year}/${month}/${day}/${hour}/${MEDIA_CALL_ID}.mp4`;

logger.logger().log("info", fileName);

new S3Uploader(BUCKET_NAME, fileName).uploadStream(
  transcodeStreamToOutput.stdout
);

// event handler for docker stop, not exit until upload completes

process.on("SIGTERM", (code, signal) => {
  logger
    .logger()
    .log("info", `exited with code ${code} and signal ${signal}(SIGTERM)`);
  process.kill(transcodeStreamToOutput.pid, "SIGTERM");
});

// debug use - event handler for ctrl + c
process.on("SIGINT", (code, signal) => {
  logger
    .logger()
    .log("info", `exited with code ${code} and signal ${signal}(SIGINT)`);
  process.kill("SIGTERM");
});

process.on("exit", function (code) {
  logger.logger().log("info", "[recording process] exit code", code);
});
